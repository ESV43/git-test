import { ComicPanel, ComicConfig, ExportOptions } from "@/types/comic";

// PDF export functionality
export class PDFExporter {
  static async exportToPDF(
    panels: ComicPanel[], 
    config: ComicConfig, 
    options: ExportOptions
  ): Promise<Blob> {
    // Use jsPDF for PDF generation
    const { jsPDF } = await import('jspdf');
    
    const pdf = new jsPDF({
      orientation: config.aspectRatio === '3:4' ? 'portrait' : 'landscape',
      unit: 'mm',
      format: 'a4'
    });

    const pageWidth = pdf.internal.pageSize.getWidth();
    const pageHeight = pdf.internal.pageSize.getHeight();
    const margin = 10;
    
    let currentPage = 0;
    const panelsPerPage = config.panelCount;
    
    for (let i = 0; i < panels.length; i += panelsPerPage) {
      if (currentPage > 0) {
        pdf.addPage();
      }
      
      const pagePanels = panels.slice(i, i + panelsPerPage);
      const rows = Math.ceil(Math.sqrt(panelsPerPage));
      const cols = Math.ceil(panelsPerPage / rows);
      
      const panelWidth = (pageWidth - margin * 2 - (cols - 1) * 5) / cols;
      const panelHeight = (pageHeight - margin * 2 - (rows - 1) * 5) / rows;
      
      for (let j = 0; j < pagePanels.length; j++) {
        const panel = pagePanels[j];
        const row = Math.floor(j / cols);
        const col = j % cols;
        
        const x = margin + col * (panelWidth + 5);
        const y = margin + row * (panelHeight + 5);
        
        if (panel.imageUrl) {
          try {
            // Add image to PDF with reduced quality for smaller file size
            const quality = options.quality === 'high' ? 0.9 : options.quality === 'medium' ? 0.7 : 0.5;
            
            if (panel.imageUrl.startsWith('data:')) {
              pdf.addImage(panel.imageUrl, 'JPEG', x, y, panelWidth, panelHeight, '', 'MEDIUM');
            } else {
              // For external URLs, we'd need to fetch and convert to base64
              const canvas = document.createElement('canvas');
              const ctx = canvas.getContext('2d');
              const img = new Image();
              
              await new Promise((resolve, reject) => {
                img.crossOrigin = 'anonymous';
                img.onload = () => {
                  canvas.width = img.width;
                  canvas.height = img.height;
                  ctx?.drawImage(img, 0, 0);
                  const dataUrl = canvas.toDataURL('image/jpeg', quality);
                  pdf.addImage(dataUrl, 'JPEG', x, y, panelWidth, panelHeight);
                  resolve(void 0);
                };
                img.onerror = reject;
                img.src = panel.imageUrl;
              });
            }
          } catch (error) {
            console.error('Failed to add image to PDF:', error);
            // Add placeholder rectangle
            pdf.rect(x, y, panelWidth, panelHeight);
            pdf.setFontSize(8);
            pdf.text('Image failed to load', x + 2, y + 10);
          }
        }
        
        // Add dialogue if enabled
        if (options.includeDialogue && panel.dialogue) {
          pdf.setFontSize(8);
          pdf.setTextColor(0, 0, 0);
          const lines = pdf.splitTextToSize(panel.dialogue, panelWidth - 4);
          pdf.text(lines, x + 2, y + panelHeight - 8);
        }
      }
      
      // Add page number
      pdf.setFontSize(8);
      pdf.setTextColor(128, 128, 128);
      pdf.text(`Page ${currentPage + 1}`, pageWidth - 20, pageHeight - 5);
      
      currentPage++;
    }
    
    // Add watermark if enabled
    if (options.watermark) {
      const totalPages = pdf.getNumberOfPages();
      for (let page = 1; page <= totalPages; page++) {
        pdf.setPage(page);
        pdf.setFontSize(12);
        pdf.setTextColor(200, 200, 200);
        pdf.text('Generated by AI Comic Creator', pageWidth - 60, 10);
      }
    }
    
    return pdf.output('blob');
  }
}